//--------------------------------------------------------------------------------------------------
// telescope mount control, axis instances

#include "Mount.h"

#ifdef MOUNT_PRESENT

#ifdef AXIS1_ODRIVE_PRESENT
  const ODriveDriverSettings DriverSettingsAxis1 = {AXIS1_DRIVER_MODEL, AXIS1_DRIVER_STATUS};
  ODriveMotor motor1(1, AXIS1_REVERSE, &DriverSettingsAxis1, (AXIS1_STEPS_PER_DEGREE*RAD_DEG_RATIO));
#endif

#ifdef AXIS1_KTECH_PRESENT
  const KTechDriverSettings DriverSettingsAxis1 = {AXIS1_DRIVER_MODEL, AXIS1_DRIVER_STATUS};
  KTechMotor motor1(1, AXIS1_REVERSE, &DriverSettingsAxis1, AXIS1_STEPS_PER_DEGREE);
#endif

#ifdef AXIS1_SERVO_PRESENT
  ServoControl servoControlAxis1;

  #if AXIS1_ENCODER == AB
    Quadrature encAxis1(1, AXIS1_ENCODER_A_PIN, AXIS1_ENCODER_B_PIN);
  #elif AXIS1_ENCODER == AB_ESP32
    QuadratureEsp32 encAxis1(1, AXIS1_ENCODER_A_PIN, AXIS1_ENCODER_B_PIN);
  #elif AXIS1_ENCODER == CW_CCW
    CwCcw encAxis1(1, AXIS1_ENCODER_A_PIN, AXIS1_ENCODER_B_PIN);
  #elif AXIS1_ENCODER == PULSE_DIR
    PulseDir encAxis1(1, AXIS1_ENCODER_A_PIN, AXIS1_ENCODER_B_PIN);
  #elif AXIS1_ENCODER == PULSE_ONLY
    PulseOnly encAxis1(1, AXIS1_ENCODER_A_PIN, &servoControlAxis1.directionHint);
  #elif AXIS1_ENCODER == VIRTUAL
    VirtualEnc encAxis1(1);
  #elif AXIS1_ENCODER == AS37_H39B_B
    As37h39bb encAxis1(1, AXIS1_ENCODER_A_PIN, AXIS1_ENCODER_B_PIN);
  #elif AXIS1_ENCODER == JTW_24BIT
    Jtw24 encAxis1(1, AXIS1_ENCODER_A_PIN, AXIS1_ENCODER_B_PIN);
  #elif AXIS1_ENCODER == JTW_26BIT
    Jtw26 encAxis1(1, AXIS1_ENCODER_A_PIN, AXIS1_ENCODER_B_PIN);
  #elif AXIS1_ENCODER == LIKA_ASC85
    LikaAsc85 encAxis1(1, AXIS1_ENCODER_A_PIN, AXIS1_ENCODER_B_PIN);
  #elif AXIS1_ENCODER == KTECH_IME
    KTechIME encAxis1(1);
  #elif AXIS1_ENCODER == SERIAL_BRIDGE
    SerialBridge encAxis1(1);
  #endif

  #if AXIS1_SERVO_FEEDBACK == PID
    Pid feedbackAxis1(AXIS1_PID_P, AXIS1_PID_I, AXIS1_PID_D);
  #elif AXIS1_SERVO_FEEDBACK == DUAL_PID
    DualPid feedbackAxis1(AXIS1_PID_P, AXIS1_PID_I, AXIS1_PID_D, AXIS1_PID_P_GOTO, AXIS1_PID_I_GOTO, AXIS1_PID_D_GOTO, AXIS1_PID_SENSITIVITY);
  #endif

  #if AXIS1_SERVO_FLTR == KALMAN
    KalmanFilter filterAxis1(AXIS1_SERVO_FLTR_MEAS_U, AXIS1_SERVO_FLTR_VARIANCE);
  #elif AXIS1_SERVO_FLTR == LEARNING
    // nothing to do as this is auotmatically created... LearningFilter filterAxis1(AXIS1_SERVO_FLTR_WSIZE, 240);
  #elif AXIS1_SERVO_FLTR == ROLLING
    RollingFilter filterAxis1(AXIS1_SERVO_FLTR_WSIZE);
  #elif AXIS1_SERVO_FLTR == WINDOWING
    WindowingFilter filterAxis1(AXIS1_SERVO_FLTR_WSIZE);
  #elif AXIS1_SERVO_FLTR == OFF
    Filter filterAxis1;
  #endif

  const ServoPins DriverPinsAxis1 = {AXIS1_SERVO_PH1_PIN, AXIS1_SERVO_PH1_STATE, AXIS1_SERVO_PH2_PIN, AXIS1_SERVO_PH2_STATE, AXIS1_ENABLE_PIN, AXIS1_ENABLE_STATE, AXIS1_M0_PIN, AXIS1_M1_PIN, AXIS1_M2_PIN, AXIS1_M3_PIN, AXIS1_FAULT_PIN};
  const ServoSettings DriverSettingsAxis1 = {AXIS1_DRIVER_MODEL, AXIS1_DRIVER_STATUS, AXIS1_SERVO_VELOCITY_MAX, AXIS1_SERVO_ACCELERATION};

  #if AXIS1_DRIVER_MODEL == SERVO_EE
    ServoEE driver1(1, &DriverPinsAxis1, &DriverSettingsAxis1, AXIS1_SERVO_DC_PWR_MIN, AXIS1_SERVO_DC_PWR_MAX);
  #elif AXIS1_DRIVER_MODEL == SERVO_PE
    ServoPE driver1(1, &DriverPinsAxis1, &DriverSettingsAxis1, AXIS1_SERVO_DC_PWR_MIN, AXIS1_SERVO_DC_PWR_MAX);
  #elif AXIS1_DRIVER_MODEL == SERVO_TMC2130_DC
    ServoTmc5160DC driver1(1, &DriverPinsAxis1, &DriverSettingsAxis1, AXIS1_SERVO_DC_PWR_MIN, AXIS1_SERVO_DC_PWR_MAX);
  #elif AXIS1_DRIVER_MODEL == SERVO_TMC5160_DC
    ServoTmc2130DC driver1(1, &DriverPinsAxis1, &DriverSettingsAxis1, AXIS1_SERVO_DC_PWR_MIN, AXIS1_SERVO_DC_PWR_MAX);
  #elif AXIS1_DRIVER_MODEL == SERVO_TMC2209
    ServoTmc2209 driver1(1, &DriverPinsAxis1, &DriverSettingsAxis1, AXIS1_MOTOR_STEPS_PER_DEGREE/AXIS1_STEPS_PER_DEGREE, AXIS1_DRIVER_MICROSTEPS, AXIS1_DRIVER_IRUN, AXIS1_DRIVER_DECAY, AXIS1_DRIVER_DECAY_GOTO);
  #elif AXIS1_DRIVER_MODEL == SERVO_TMC5160
    ServoTmc5160 driver1(1, &DriverPinsAxis1, &DriverSettingsAxis1, AXIS1_MOTOR_STEPS_PER_DEGREE/AXIS1_STEPS_PER_DEGREE, AXIS1_DRIVER_MICROSTEPS, AXIS1_DRIVER_IRUN, AXIS1_DRIVER_DECAY, AXIS1_DRIVER_DECAY_GOTO);
  #elif AXIS1_DRIVER_MODEL == SERVO_KTECH
    ServoKTech driver1(1, &DriverSettingsAxis1, AXIS1_MOTOR_STEPS_PER_DEGREE/AXIS1_STEPS_PER_DEGREE);
  #endif

  ServoMotor motor1(1, AXIS1_REVERSE, ((ServoDriver*)&driver1), &filterAxis1, &encAxis1, AXIS1_ENCODER_ORIGIN, AXIS1_ENCODER_REVERSE == ON, &feedbackAxis1, &servoControlAxis1, AXIS1_SYNC_THRESHOLD);
#endif

#ifdef AXIS1_STEP_DIR_PRESENT
  const StepDirDriverPins DriverPinsAxis1 = {AXIS1_M0_PIN, AXIS1_M1_PIN, AXIS1_M2_PIN, AXIS1_M2_ON_STATE, AXIS1_M3_PIN, AXIS1_DECAY_PIN, AXIS1_FAULT_PIN};
  const StepDirDriverSettings DriverSettingsAxis1 = {AXIS1_DRIVER_MODEL, AXIS1_DRIVER_STATUS, AXIS1_DRIVER_MICROSTEPS, AXIS1_DRIVER_MICROSTEPS_GOTO, AXIS1_DRIVER_DECAY, AXIS1_DRIVER_DECAY_GOTO};
  #if AXIS1_DRIVER_MODEL >= STEP_DIR_DRIVER_FIRST && AXIS1_DRIVER_MODEL < TMC_DRIVER_FIRST
    StepDirGeneric driver1(1, &DriverPinsAxis1, &DriverSettingsAxis1);
  #elif AXIS1_DRIVER_MODEL == TMC2130
    StepDirTmc2130 driver1(1, &DriverPinsAxis1, &DriverSettingsAxis1, AXIS1_DRIVER_IHOLD, AXIS1_DRIVER_IRUN, AXIS1_DRIVER_IGOTO, AXIS1_DRIVER_INTPOL);
  #elif AXIS1_DRIVER_MODEL == TMC2160
    StepDirTmc2160 driver1(1, &DriverPinsAxis1, &DriverSettingsAxis1, AXIS1_DRIVER_IHOLD, AXIS1_DRIVER_IRUN, AXIS1_DRIVER_IGOTO, AXIS1_DRIVER_INTPOL);
  #elif AXIS1_DRIVER_MODEL == TMC2208
    StepDirTmc2208 driver1(1, &DriverPinsAxis1, &DriverSettingsAxis1, AXIS1_DRIVER_IHOLD, AXIS1_DRIVER_IRUN, AXIS1_DRIVER_IGOTO, AXIS1_DRIVER_INTPOL);
  #elif AXIS1_DRIVER_MODEL == TMC2209 || AXIS1_DRIVER_MODEL == TMC2226
    StepDirTmc2209 driver1(1, &DriverPinsAxis1, &DriverSettingsAxis1, AXIS1_DRIVER_IHOLD, AXIS1_DRIVER_IRUN, AXIS1_DRIVER_IGOTO, AXIS1_DRIVER_INTPOL);
  #elif AXIS1_DRIVER_MODEL == TMC2660
    StepDirTmc2660 driver1(1, &DriverPinsAxis1, &DriverSettingsAxis1, AXIS1_DRIVER_IHOLD, AXIS1_DRIVER_IRUN, AXIS1_DRIVER_IGOTO, AXIS1_DRIVER_INTPOL);
  #elif AXIS1_DRIVER_MODEL == TMC5160
    StepDirTmc5160 driver1(1, &DriverPinsAxis1, &DriverSettingsAxis1, AXIS1_DRIVER_IHOLD, AXIS1_DRIVER_IRUN, AXIS1_DRIVER_IGOTO, AXIS1_DRIVER_INTPOL);
  #elif AXIS1_DRIVER_MODEL == TMC5161
    StepDirTmc5161 driver1(1, &DriverPinsAxis1, &DriverSettingsAxis1, AXIS1_DRIVER_IHOLD, AXIS1_DRIVER_IRUN, AXIS1_DRIVER_IGOTO, AXIS1_DRIVER_INTPOL);
  #endif

  const StepDirPins StepDirPinsAxis1 = {AXIS1_STEP_PIN, AXIS1_STEP_STATE, AXIS1_DIR_PIN, AXIS1_ENABLE_PIN, AXIS1_ENABLE_STATE};
  StepDirMotor motor1(1, AXIS1_REVERSE, &StepDirPinsAxis1, ((StepDirDriver*)&driver1));
#endif

const AxisPins PinsAxis1 = {AXIS1_SENSE_LIMIT_MIN_PIN, AXIS1_SENSE_HOME_PIN, AXIS1_SENSE_LIMIT_MAX_PIN, {AXIS1_SENSE_HOME, AXIS1_SENSE_HOME_INIT, degToRadF(AXIS1_SENSE_HOME_DIST_LIMIT), AXIS1_SENSE_LIMIT_MIN, AXIS1_SENSE_LIMIT_MAX, AXIS1_SENSE_LIMIT_INIT}};
const AxisSettings SettingsAxis1 = {AXIS1_STEPS_PER_DEGREE*RAD_DEG_RATIO, {degToRadF(AXIS1_LIMIT_MIN), degToRadF(AXIS1_LIMIT_MAX)}, siderealToRad(TRACK_BACKLASH_RATE)};
Axis axis1(1, &PinsAxis1, &SettingsAxis1, AXIS_MEASURE_RADIANS, arcsecToRad(AXIS1_TARGET_TOLERANCE));

#ifdef AXIS2_ODRIVE_PRESENT
  const ODriveDriverSettings DriverSettingsAxis2 = {AXIS2_DRIVER_MODEL, AXIS2_DRIVER_STATUS};
  ODriveMotor motor2(2, AXIS2_REVERSE, &DriverSettingsAxis2, (AXIS2_STEPS_PER_DEGREE*RAD_DEG_RATIO));
#endif

#ifdef AXIS2_KTECH_PRESENT
  const KTechDriverSettings DriverSettingsAxis2 = {AXIS2_DRIVER_MODEL, AXIS2_DRIVER_STATUS};
  KTechMotor motor2(2, AXIS2_REVERSE, &DriverSettingsAxis2);
#endif

#ifdef AXIS2_SERVO_PRESENT
  ServoControl servoControlAxis2;

  #if AXIS2_ENCODER == AB
    Quadrature encAxis2(2, AXIS2_ENCODER_A_PIN, AXIS2_ENCODER_B_PIN);
  #elif AXIS2_ENCODER == AB_ESP32
    QuadratureEsp32 encAxis2(2, AXIS2_ENCODER_A_PIN, AXIS2_ENCODER_B_PIN);
  #elif AXIS2_ENCODER == CW_CCW
    CwCcw encAxis2(2, AXIS2_ENCODER_A_PIN, AXIS2_ENCODER_B_PIN);
  #elif AXIS2_ENCODER == PULSE_DIR
    PulseDir encAxis2(2, AXIS2_ENCODER_A_PIN, AXIS2_ENCODER_B_PIN);
  #elif AXIS2_ENCODER == PULSE_ONLY
    PulseOnly encAxis2(2, AXIS2_ENCODER_A_PIN, &servoControlAxis2.directionHint);
  #elif AXIS2_ENCODER == VIRTUAL
    VirtualEnc encAxis2(2);
  #elif AXIS2_ENCODER == AS37_H39B_B
    As37h39bb encAxis2(2, AXIS2_ENCODER_A_PIN, AXIS2_ENCODER_B_PIN);
  #elif AXIS2_ENCODER == JTW_24BIT
    Jtw24 encAxis2(2, AXIS2_ENCODER_A_PIN, AXIS2_ENCODER_B_PIN);
  #elif AXIS2_ENCODER == JTW_26BIT
    Jtw26 encAxis2(2, AXIS2_ENCODER_A_PIN, AXIS2_ENCODER_B_PIN);
  #elif AXIS2_ENCODER == LIKA_ASC85
    LikaAsc85 encAxis2(2, AXIS2_ENCODER_A_PIN, AXIS2_ENCODER_B_PIN);
  #elif AXIS2_ENCODER == KTECH_IME
    KTechIME encAxis2(2);
  #elif AXIS2_ENCODER == SERIAL_BRIDGE
    SerialBridge encAxis2(2);
  #endif

  #if AXIS2_SERVO_FEEDBACK == PID
    Pid feedbackAxis2(AXIS2_PID_P, AXIS2_PID_I, AXIS2_PID_D);
  #elif AXIS2_SERVO_FEEDBACK == DUAL_PID
    DualPid feedbackAxis2(AXIS2_PID_P, AXIS2_PID_I, AXIS2_PID_D, AXIS2_PID_P_GOTO, AXIS2_PID_I_GOTO, AXIS2_PID_D_GOTO, AXIS2_PID_SENSITIVITY);
  #endif

  #if AXIS2_SERVO_FLTR == KALMAN
    KalmanFilter filterAxis2(AXIS2_SERVO_FLTR_MEAS_U, AXIS2_SERVO_FLTR_VARIANCE);
  #elif AXIS2_SERVO_FLTR == ROLLING
    RollingFilter filterAxis2(AXIS2_SERVO_FLTR_WSIZE);
  #elif AXIS2_SERVO_FLTR == WINDOWING
    WindowingFilter filterAxis2(AXIS2_SERVO_FLTR_WSIZE);
  #elif AXIS2_SERVO_FLTR == OFF
    Filter filterAxis2;
  #endif

  const ServoPins DriverPinsAxis2 = {AXIS2_SERVO_PH1_PIN, AXIS2_SERVO_PH1_STATE, AXIS2_SERVO_PH2_PIN, AXIS2_SERVO_PH2_STATE, AXIS2_ENABLE_PIN, AXIS2_ENABLE_STATE, AXIS2_M0_PIN, AXIS2_M1_PIN, AXIS2_M2_PIN, AXIS2_M3_PIN, AXIS2_FAULT_PIN};
  const ServoSettings DriverSettingsAxis2 = {AXIS2_DRIVER_MODEL, AXIS2_DRIVER_STATUS, AXIS2_SERVO_VELOCITY_MAX, AXIS2_SERVO_ACCELERATION};

  #if AXIS2_DRIVER_MODEL == SERVO_EE
    ServoEE driver2(2, &DriverPinsAxis2, &DriverSettingsAxis2, AXIS2_SERVO_DC_PWR_MIN, AXIS2_SERVO_DC_PWR_MAX);
  #elif AXIS2_DRIVER_MODEL == SERVO_PE
    ServoPE driver2(2, &DriverPinsAxis2, &DriverSettingsAxis2, AXIS2_SERVO_DC_PWR_MIN, AXIS2_SERVO_DC_PWR_MAX);
  #elif AXIS2_DRIVER_MODEL == SERVO_TMC2130_DC
    ServoTmc2130DC driver2(2, &DriverPinsAxis2, &DriverSettingsAxis2, AXIS2_SERVO_DC_PWR_MIN, AXIS2_SERVO_DC_PWR_MAX);
  #elif AXIS2_DRIVER_MODEL == SERVO_TMC5160_DC
    ServoTmc5160DC driver2(2, &DriverPinsAxis2, &DriverSettingsAxis2, AXIS2_SERVO_DC_PWR_MIN, AXIS2_SERVO_DC_PWR_MAX);
  #elif AXIS2_DRIVER_MODEL == SERVO_TMC2209
    ServoTmc2209 driver2(2, &DriverPinsAxis2, &DriverSettingsAxis2, AXIS2_MOTOR_STEPS_PER_DEGREE/AXIS2_STEPS_PER_DEGREE, AXIS2_DRIVER_MICROSTEPS, AXIS2_DRIVER_IRUN, AXIS2_DRIVER_DECAY, AXIS2_DRIVER_DECAY_GOTO);
  #elif AXIS2_DRIVER_MODEL == SERVO_TMC5160
    ServoTmc5160 driver2(2, &DriverPinsAxis2, &DriverSettingsAxis2, AXIS2_MOTOR_STEPS_PER_DEGREE/AXIS2_STEPS_PER_DEGREE, AXIS2_DRIVER_MICROSTEPS, AXIS2_DRIVER_IRUN, AXIS2_DRIVER_DECAY, AXIS2_DRIVER_DECAY_GOTO);
  #elif AXIS2_DRIVER_MODEL == SERVO_KTECH
    ServoKTech driver2(2, &DriverSettingsAxis2, AXIS2_MOTOR_STEPS_PER_DEGREE/AXIS2_STEPS_PER_DEGREE);
  #endif

  ServoMotor motor2(2, AXIS2_REVERSE, ((ServoDriver*)&driver2), &filterAxis2, &encAxis2, AXIS2_ENCODER_ORIGIN, AXIS2_ENCODER_REVERSE == ON, &feedbackAxis2, &servoControlAxis2, AXIS2_SYNC_THRESHOLD);
  IRAM_ATTR void moveAxis2() { motor2.move(); }
#endif

#ifdef AXIS2_STEP_DIR_PRESENT
  const StepDirDriverPins DriverPinsAxis2 = {AXIS2_M0_PIN, AXIS2_M1_PIN, AXIS2_M2_PIN, AXIS2_M2_ON_STATE, AXIS2_M3_PIN, AXIS2_DECAY_PIN, AXIS2_FAULT_PIN};
  const StepDirDriverSettings DriverSettingsAxis2 = {AXIS2_DRIVER_MODEL, AXIS2_DRIVER_STATUS, AXIS2_DRIVER_MICROSTEPS, AXIS2_DRIVER_MICROSTEPS_GOTO, AXIS2_DRIVER_DECAY, AXIS2_DRIVER_DECAY_GOTO};
  #if AXIS2_DRIVER_MODEL >= STEP_DIR_DRIVER_FIRST && AXIS2_DRIVER_MODEL < TMC_DRIVER_FIRST
    StepDirGeneric driver2(2, &DriverPinsAxis2, &DriverSettingsAxis2);
  #elif AXIS2_DRIVER_MODEL == TMC2130
    StepDirTmc2130 driver2(2, &DriverPinsAxis2, &DriverSettingsAxis2, AXIS2_DRIVER_IHOLD, AXIS2_DRIVER_IRUN, AXIS2_DRIVER_IGOTO, AXIS2_DRIVER_INTPOL);
  #elif AXIS2_DRIVER_MODEL == TMC2160
    StepDirTmc2160 driver2(2, &DriverPinsAxis2, &DriverSettingsAxis2, AXIS2_DRIVER_IHOLD, AXIS2_DRIVER_IRUN, AXIS2_DRIVER_IGOTO, AXIS2_DRIVER_INTPOL);
  #elif AXIS2_DRIVER_MODEL == TMC2208
    StepDirTmc2208 driver2(2, &DriverPinsAxis2, &DriverSettingsAxis2, AXIS2_DRIVER_IHOLD, AXIS2_DRIVER_IRUN, AXIS2_DRIVER_IGOTO, AXIS2_DRIVER_INTPOL);
  #elif AXIS2_DRIVER_MODEL == TMC2209 || AXIS2_DRIVER_MODEL == TMC2226
    StepDirTmc2209 driver2(2, &DriverPinsAxis2, &DriverSettingsAxis2, AXIS2_DRIVER_IHOLD, AXIS2_DRIVER_IRUN, AXIS2_DRIVER_IGOTO, AXIS2_DRIVER_INTPOL);
  #elif AXIS2_DRIVER_MODEL == TMC2660
    StepDirTmc2660 driver2(2, &DriverPinsAxis2, &DriverSettingsAxis2, AXIS2_DRIVER_IHOLD, AXIS2_DRIVER_IRUN, AXIS2_DRIVER_IGOTO, AXIS2_DRIVER_INTPOL);
  #elif AXIS2_DRIVER_MODEL == TMC5160
    StepDirTmc5160 driver2(2, &DriverPinsAxis2, &DriverSettingsAxis2, AXIS2_DRIVER_IHOLD, AXIS2_DRIVER_IRUN, AXIS2_DRIVER_IGOTO, AXIS2_DRIVER_INTPOL);
  #elif AXIS2_DRIVER_MODEL == TMC5161
    StepDirTmc5161 driver2(2, &DriverPinsAxis2, &DriverSettingsAxis2, AXIS2_DRIVER_IHOLD, AXIS2_DRIVER_IRUN, AXIS2_DRIVER_IGOTO, AXIS2_DRIVER_INTPOL);
  #endif

  const StepDirPins StepDirPinsAxis2 = {AXIS2_STEP_PIN, AXIS2_STEP_STATE, AXIS2_DIR_PIN, AXIS2_ENABLE_PIN, AXIS2_ENABLE_STATE};
  StepDirMotor motor2(2, AXIS2_REVERSE, &StepDirPinsAxis2, ((StepDirDriver*)&driver2));
#endif

const AxisPins PinsAxis2 = {AXIS2_SENSE_LIMIT_MIN_PIN, AXIS2_SENSE_HOME_PIN, AXIS2_SENSE_LIMIT_MAX_PIN, {AXIS2_SENSE_HOME, AXIS2_SENSE_HOME_INIT, degToRadF(AXIS2_SENSE_HOME_DIST_LIMIT), AXIS2_SENSE_LIMIT_MIN, AXIS2_SENSE_LIMIT_MAX, AXIS2_SENSE_LIMIT_INIT}};
const AxisSettings SettingsAxis2 = {AXIS2_STEPS_PER_DEGREE*RAD_DEG_RATIO, {degToRadF(AXIS2_LIMIT_MIN), degToRadF(AXIS2_LIMIT_MAX)}, siderealToRad(TRACK_BACKLASH_RATE)};
Axis axis2(2, &PinsAxis2, &SettingsAxis2, AXIS_MEASURE_RADIANS, arcsecToRad(AXIS2_TARGET_TOLERANCE));

#endif
